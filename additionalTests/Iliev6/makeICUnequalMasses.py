#!/usr/bin/env python3
###############################################################################
# This file is part of SWIFT.
# Copyright (c) 2022 Mladen Ivkovic (mladen.ivkovic@hotmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

# ---------------------------------------------------------------------
# Add a single star in the center of a glass distribution
# The gas is set up with pure hydrogen gas.
# The ICs enforce a 1/r^2 density profile, where the density gradient
# is generated by modifying particle masses. This might not be optimal
# for SPH schemes.
# ---------------------------------------------------------------------

import h5py
import numpy as np
import unyt
from scipy import stats
from swiftsimio import Writer
from swiftsimio.units import cosmo_units

import stromgren_plotting_tools as spt

gamma = 5.0 / 3.0

# switch to replace the central gas particle with a star
# else put the star particle among gas particles
replace_gas = True

#  resolution = 64
resolution = 128

r_0 = 91.5 * unyt.pc
n_0 = 3.2 / unyt.cm ** 3
rho_0 = n_0 * unyt.proton_mass


def reference_density(ri):
    """
    return density at radius ri
    ri shall be a unyt quantity
    """
    if ri <= r_0:
        return rho_0
    else:
        return rho_0 * (r_0 / ri) ** 2


if __name__ == "__main__":

    glass = h5py.File("glassCube_" + str(resolution) + ".hdf5", "r")
    parts = glass["PartType0"]
    xp = parts["Coordinates"][:]
    h = parts["SmoothingLength"][:]
    glass.close()

    r = np.sqrt(np.sum((0.5 - xp) ** 2, axis=1))

    if replace_gas:
        # replace a central gas particle with a star particle
        rmin = np.argmin(r)
        xs = xp[rmin]
        xp = np.delete(xp, rmin, axis=0)
        h = np.delete(h, rmin)
    else:
        # find particles closest to the center
        # and select a couple of them to put the star in their middle
        mininds = np.argsort(r)
        center_parts = xp[mininds[:4]]
        xs = center_parts.sum(axis=0) / center_parts.shape[0]

    # Double-check all particles for boundaries
    for i in range(3):
        mask = xp[:, i] < 0.0
        xp[mask, i] += 1.0
        mask = xp[:, i] > 1.0
        xp[mask, i] -= 1.0

    # Add border particles
    border_particle_width = 4
    dx = 1.0 / (resolution + 2 * border_particle_width)
    scale = resolution / (resolution + 2 * border_particle_width)
    shift = 0.5 * (1.0 - scale)
    if scale < 0:
        print("scale =", scale, "???")
        quit()

    # Set up metadata
    unitL = unyt.Mpc
    edgelen = 1.6 * 1e-3 * (resolution + 2 * border_particle_width) / resolution * unitL
    edgelen = edgelen.to(unitL)
    boxsize = np.array([1.0, 1.0, 1.0]) * edgelen

    # scale positions down
    xp *= scale
    xp += shift
    pid = np.arange(1000000001, 1000000001 + h.shape[0], 1)

    npart_border = (resolution + 2 * border_particle_width) ** 3 - resolution ** 3

    xp_border = np.zeros((npart_border, 3))
    h_border = np.ones(npart_border)
    pid_border = np.arange(1, npart_border + 1, 1)
    ind = 0

    for i in range(resolution + 2 * border_particle_width):
        x = (i + 0.5) * dx
        for j in range(resolution + 2 * border_particle_width):
            y = (j + 0.5) * dx
            for k in range(resolution + 2 * border_particle_width):
                z = (k + 0.5) * dx

                is_border = False
                is_border = is_border or x < shift or x > 1.0 - shift
                is_border = is_border or y < shift or y > 1.0 - shift
                is_border = is_border or z < shift or z > 1.0 - shift

                if is_border:
                    xp_border[ind, 0] = x
                    xp_border[ind, 1] = y
                    xp_border[ind, 2] = z
                    ind += 1

    if ind != npart_border:
        print("oh no")
        quit()

    h_mean = np.mean(h)
    # take estimate for sml
    h_border = h_border * h_mean

    # concatenate arraays
    xp = np.concatenate((xp, xp_border), axis=0)
    h = np.concatenate((h, h_border), axis=0)
    pid = np.concatenate((pid, pid_border), axis=0)

    # Get density profile by adapting particle masses.
    # update r to include boundary particles
    r = np.sqrt(np.sum((0.5 - xp) ** 2, axis=1))
    nbins = 2 * resolution
    r_bin_edges = np.linspace(0.0, 0.5 * np.sqrt(3), nbins + 1)
    r_bin_centers = 0.5 * (r_bin_edges[:-1] + r_bin_edges[1:])

    partnumber, _, binnumber = stats.binned_statistic(
        r, np.ones(r.shape), statistic="sum", bins=r_bin_edges
    )

    density_expect = np.zeros(r_bin_centers.shape) * rho_0
    for i, ri in enumerate(r_bin_centers):
        ri_units = ri * edgelen
        rho_i = reference_density(ri_units)
        density_expect[i] = rho_i

    shell_volumes = (
        4.0 / 3 * np.pi * (r_bin_edges[1:] ** 3 - r_bin_edges[:-1] ** 3) * edgelen ** 3
    )
    av_mass = density_expect * shell_volumes / partnumber

    masses = np.ones(r.shape) * av_mass[binnumber - 1]
    masses = masses.to(cosmo_units["mass"])

    # For particles with r > boxlen_ref, this estimate will be wrong
    # because of missing particles. Instead, try to get a better
    # estimat using an average particle volume.
    V_average = edgelen ** 3 / r.shape[0]

    for i in range(r.shape[0]):
        if r[i] > 0.5:
            rho_expect = reference_density(r[i] * edgelen)
            m_expect = rho_expect * V_average
            masses[i] = m_expect.to(masses.units)

    # convert to correct units
    xp *= edgelen
    h *= edgelen

    xs = unyt.unyt_array(
        [np.array([xs[0] * edgelen, xs[1] * edgelen, xs[2] * edgelen])], unitL
    )

    w = Writer(unit_system=cosmo_units, box_size=boxsize, dimension=3)

    # write particle positions and smoothing lengths
    w.gas.coordinates = xp
    w.gas.particle_ids = pid

    w.stars.coordinates = xs
    # you  got to give all particle types an ID, otherwise swiftsimio
    # will generate the IDs itself
    w.stars.particle_ids = np.ones(1, dtype=int) * 2000000001
    w.gas.velocities = np.zeros(xp.shape) * (unitL / unyt.Myr)
    w.stars.velocities = np.zeros(xs.shape) * (unitL / unyt.Myr)
    w.gas.smoothing_length = h
    w.stars.smoothing_length = w.gas.smoothing_length[:1]

    # get gas masses
    w.gas.masses = masses
    w.stars.masses = np.ones(xs.shape[0], dtype=np.float64) * w.gas.masses.max()

    # get gas internal energy for a given temperature and composition
    XH = 1.0  # hydrogen mass fraction
    XHe = 0.0  # helium mass fraction
    T = 100 * unyt.K
    XHI, XHII, XHeI, XHeII, XHeIII = spt.get_mass_fractions(T, XH, XHe)
    mu = spt.mean_molecular_weight(XHI, XHII, XHeI, XHeII, XHeIII)
    internal_energy = spt.internal_energy(T, mu, gamma)

    w.gas.internal_energy = np.ones(xp.shape[0], dtype=np.float64) * internal_energy

    w.write("ilievTest6UnequalMasses.hdf5")
